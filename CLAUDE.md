# CLAUDE.md

This file provides guidance to Claude Code when working with code in this repository.

## Project Overview

This project re-implements Autoware's `ndt_scan_matcher` in CUDA and Rust. The reference implementation is at `external/autoware_core/localization/autoware_ndt_scan_matcher/`.

NDT (Normal Distributions Transform) scan matching is used for position estimation in autonomous driving. Key features:
- Estimate position by scan matching against a point cloud map
- Initial position estimation via Monte Carlo method
- Optional regularization using GNSS

## Implementation Status

**Phase 1 + 2: COMPLETE**

| Component | Status |
|-----------|--------|
| fast-gicp integration | ✅ |
| PointCloud2 conversion | ✅ |
| NDT alignment (NDTCuda) | ✅ |
| ROS subscriptions (points_raw, ekf_pose, regularization_pose) | ✅ |
| ROS publishers (ndt_pose, ndt_pose_with_covariance) | ✅ |
| trigger_node_srv service | ✅ |
| All parameters from config | ✅ |
| Launch file with remappings | ✅ |

**Remaining phases:** Covariance Estimation, Initial Pose Estimation, Dynamic Map Loading, Validation & Diagnostics, Performance Optimization

## Build System

The project uses `colcon-cargo-ros2` for Rust ROS 2 integration.

### Prerequisites

```bash
# Source ROS 2 (required before any build)
source /opt/ros/humble/setup.bash

# Or use direnv (recommended)
direnv allow  # Sources .envrc which handles ROS setup
```

### Build Commands

```bash
just build    # colcon build with --release
just clean    # rm -rf build install log src/target
just format   # Format code with rustfmt
just lint     # Run format check and clippy (requires build first)
just test     # Run tests (requires build first)
just quality  # Run lint + test
```

**Important:** Always source ROS before building. The `.envrc` file handles this automatically if using direnv.

### Running

```bash
# Source the workspace after building
source install/setup.bash

# Run the node
ros2 run cuda_ndt_matcher cuda_ndt_matcher

# Or use the launch file
ros2 launch cuda_ndt_matcher_launch ndt_scan_matcher.launch.xml
```

## Project Structure

```
cuda_ndt_matcher/
├── docs/                        # Design documentation
│   ├── overview.md              # Project goals and strategy
│   ├── architecture.md          # System architecture, ROS interface
│   ├── integration.md           # fast_gicp_rust + cubecl usage
│   └── roadmap.md               # Phased work items with tests
├── external/
│   ├── autoware_core/.../autoware_ndt_scan_matcher/  # C++ reference
│   └── fast_gicp_rust/          # Rust CUDA NDT bindings
│       ├── fast-gicp/           # High-level Rust API
│       ├── fast-gicp-sys/       # C++ FFI layer
│       └── fast_gicp/           # Upstream C++ (git submodule, has COLCON_IGNORE)
├── src/
│   ├── Cargo.toml               # Workspace root
│   ├── target/                  # Cargo build output (has COLCON_IGNORE)
│   ├── cuda_ndt_matcher/        # Main ROS package (Rust)
│   │   ├── src/
│   │   │   ├── main.rs          # Node entry point, subscriptions, publishers
│   │   │   ├── ndt_manager.rs   # NDTCuda wrapper with nalgebra transforms
│   │   │   ├── params.rs        # ROS parameters from config
│   │   │   └── pointcloud.rs    # PointCloud2 <-> Vec<[f32;3]> conversion
│   │   ├── Cargo.toml
│   │   └── package.xml
│   └── cuda_ndt_matcher_launch/ # Launch package (CMake)
│       ├── launch/ndt_scan_matcher.launch.xml
│       ├── config/ndt_scan_matcher.param.yaml
│       ├── CMakeLists.txt
│       └── package.xml
├── build/                       # Generated by colcon
├── .envrc                       # direnv config (sources ROS)
└── justfile
```

## COLCON_IGNORE Files

These prevent colcon from picking up unwanted CMake packages:
- `external/fast_gicp_rust/fast_gicp/COLCON_IGNORE` - Upstream C++ library
- `src/target/COLCON_IGNORE` - Cargo build artifacts (contains vendored C++)

## Reference Implementation

The Autoware `ndt_scan_matcher` at `external/autoware_core/localization/autoware_ndt_scan_matcher/` includes:

- `ndt_scan_matcher_core.hpp/cpp`: Main ROS node implementation
- `ndt_omp/`: OpenMP-parallelized NDT algorithm
- `map_update_module.hpp/cpp`: Dynamic map loading
- `particle.hpp/cpp`: Particle representation for Monte Carlo
- `hyper_parameters.hpp`: Configuration parameters

## fast_gicp_rust

`external/fast_gicp_rust/` provides Rust bindings for CUDA-accelerated point cloud registration.

**Key types:**
- `NDTCuda` - GPU NDT via `NDTCuda::builder().resolution().build()`
- `PointCloudXYZ` - Point cloud via `PointCloudXYZ::from_points(&[[f32;3]])`
- `Transform3f` - 4x4 transform matrix
- `NdtDistanceMode` - P2D (point-to-distribution) or D2D
- `NeighborSearchMethod` - Direct1, Direct7, Direct27

**API pattern:**
```rust
let ndt = NDTCuda::builder()
    .resolution(2.0)
    .max_iterations(30)
    .transformation_epsilon(0.01)
    .distance_mode(NdtDistanceMode::P2D)
    .neighbor_search_method(NeighborSearchMethod::Direct7)
    .build()?;

let result = ndt.align_with_guess(&source, &target, Some(&initial_transform))?;
// result.has_converged, result.fitness_score, result.final_transformation
```

## Development Notes

### ROS 2 Rust Patterns (from LCTK reference)

**Service callbacks:**
```rust
node.create_service::<SetBool, _>("service_name", move |req: Request, _info: ServiceInfo| {
    Response { success: true, message: "OK".to_string() }
})?
```

**Parameters:**
```rust
let value: String = node
    .declare_parameter::<Arc<str>>("param.name")
    .default("default".into())
    .mandatory()?
    .get()
    .to_string();
```

**Executor:**
```rust
use rclrs::{Context, CreateBasicExecutor};  // Must import trait
let mut executor = Context::default_from_env()?.create_basic_executor();
```

### Transform Conversions

Use nalgebra for rotation conversions (not manual quaternion math):
```rust
use nalgebra::{Isometry3, UnitQuaternion, Translation3};

// Pose to transform
let translation = Translation3::new(p.x, p.y, p.z);
let quaternion = UnitQuaternion::from_quaternion(NaQuaternion::new(q.w, q.x, q.y, q.z));
let isometry = Isometry3::from_parts(translation, quaternion);
let matrix = isometry.to_homogeneous();

// Transform to quaternion
let rotation = nalgebra::Rotation3::from_matrix_unchecked(rotation_matrix);
let quaternion = UnitQuaternion::from_rotation_matrix(&rotation);
```

### Build Gotchas

- `ament_cargo` does NOT install data files (launch, config) - use separate CMake package
- Cargo workspace must be at `src/Cargo.toml`, not project root
- `build/ros2_cargo_config.toml` generated by colcon, needed for standalone cargo commands
- Git submodules in external dependencies need `git submodule update --init --recursive`
- Add COLCON_IGNORE to directories containing unwanted CMakeLists.txt

## Coding Conventions

- Use named parameters in format strings: `println!("{e}")` not `println!("{}", e)`
- Use nalgebra for all rotation/transform math
- Prefer `Arc<ArcSwap<T>>` over `Arc<Mutex<T>>` for read-heavy concurrent access
- Clone variables in a local scope before moving into closures
- Use type aliases for ROS service types: `type SetBoolRequest = std_srvs::srv::SetBool_Request;`
